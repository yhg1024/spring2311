# 스프링 프레임워크란?
   (Spring Framework)
   spring6
   jdk17

1) 의존 주입(Dependency Inject : DI) 지원
2) AOP(Aspect-Oriented Programming) 지원
    - 프록시(proxy) : 대신하다, 대리하다.

3) MVC 웹 프레임워크 제공
    - spring-webmvc

4) JDBC, JPA 연동, 선언적 트랜잭션 처리 등 DB 연동 지원
   JPA(Java Persistence API - ORM 표준 설계)

5) 스프링 데이터 : 추상화된 틀 제공<br>
   스프링 시큐리티 : 인증, 인가(접근제한) <br>
   스프링 배치


# 스프링 프로젝트 생성하기
   spring-context 의존성



# 스프링은 객체 컨테이너
   IoC - Inversion Of Control : 제어의 역전
   - 개발자가 해야되는 객체의 관리 -> 스프링 컨테이너가 대신 수행

    - 다양한 방식으로 객체 관리
        1) 모든 관리 객체가 싱글턴 객체(동일 객체)

# 스프링 DI(Dependency Injection - 의존주입)

0) 의존(Dependency)
    - 협동, 상호작용

1) DI를 통한 의존 처리
2) DI와 의존 객체 변경의 유연함

5.  객체 조립기

클래스 클래스 : 클래스라고 하는 정보가 담겨있는 객체

` AnnotationConfigApplicationContext ctx = new
AnnotationConfigApplicationContext(AppCtx.class);  `

애노태이션으로 설정?담는 스프링 컨테이너 <br>
ApplicationContext : 스프링 컨테이너 : 객체가 담겨있고 필요할 때마다 꺼내준다.<br>
어떤 객체가 담겨 있는지는 설정으로 알려준다.<br>
Bean으로 알려준다.<br>
애노테이션 : 클래스클래스의 정보의 일부분<br>
AnnotationConfig : 설정방식<br>
AppCtx.class : 정보(설정)이 담긴 클래스 클래스<br>
@Configuration : 설정클래스라고 알려주는 애노테이션<br>

static : 객체를 안만든다.

! 중요
BeanFactory : 
ApplicationContext :
AnnotationConfigApplicationContext(Class<?>... componentClasses) : ... 가변적인 매개변수


함수 이름 (메서드 명) - 함수의 시그니쳐
패키지명 | 클래스명 | 반환값 타입 | 함수명 | 매개변수 타입 | 예외 전가

메서드 오버로드가 가능한것은 다른 함수라서 가능하다.

RuntimeException : 실행 오류 예외 처리 : 예외가 체크된 시간의 차이

오류 : 시스템 오류
예외 : 통제 가능

FileNotFoundException : 런타임이 없고 , 컴파일 시에
ArithmeticException : 런타임이 있다. 실행중에
컴파일할때 차이가 난다.

class파일(컴파일) 실행중에 런타임 체크?

### Exception 
   - 컴파일 시점에 예외를 체크 -> 이상 -> 컴파일x
   - 엄격한 예외, 형식 중요! - 예외가 있던 없던 무조건 예외처리가 필요

### RuntimeException 
   - 실행 중에 예외를 체크 -> 실행이 되려면? 컴파일이 o -> 컴파일 o
   - 유연한 예외, 예외가 발생하는 상황이 되더라도 실행된다.
   - 예외발생 -> 중단
   - 서비스 중단을 막기 위해서 -> 적절한 예외 처리 O

`try{
   // 예외가 발생할 가능성이 있는 코드
} catch (예외 객체) {
   // 예외에 대한 후속 처리
}`

생성자만 예외처리해도 된다.?

기능의 확장 : 상속
인터페이스로 상속의 기능확장을 유연하게 한다.<br>
default 메서드 : 인스턴스 정의?

C -> B -> A 상속
super는 중요해서 자동으로 추가가 된다.

this : 지역변수 -> 참조 변수<br>
this() : 생성자 메서드

super : 지역 변수 : 상위 클래스의 객체의 참조 변수<br>
super() : 상위 클래스 생성자 메서드

C() -> super() : B() -> A()

상속은 인스턴스 자원만

다형성 : 하위클래스는 상위클래스가 될 수 있다. 출처가 명확하기 때문이다. <br>
상위 클래스는 출처가 동일한지 모르기 때문에 하위클래스가 될 수 없다. <br>
instanceof : 동일한지 확인, 객체의 출처 확인

상위 클래스 -> 일반적인 개념 <br>
하위 클래스 -> 구체적인 개념

배열 : 같은 자료형, 연속적으로 나열된

생성자 함수(메소드) - 객체들 생성하는 역할 (힙 메모리에 필요한 자원을 위한 공간 할당)

데이터 영역 : 클래스도 코드가 올라와있어야 참고해서 객체를 만들수 있다. 코드와 상수
method는 하나만 공유한다.<br>
method override : 본인거 먼저 나오고 없으면 거슬러 올라가면서 동일한게 있는지 확인, 하위에서부터 확인

@Override : 재정의한 메소드라고 알려줌

모든 클래스의 정점은 추상클래스나 , 인터페이스

### 추상클래스
- 설계, 공통자원 정의
- 공통기능 추가
- 객체가 될수 없다.
- 추상메서드면 추상 클래스여야한다.

### 객체 생성과정
- new 하고 공간할당
- 힙 메모리공간에 각각의 생성
- 메서드가 구현된게 없어 추상은 객체가 될 수없다.
- 상속을 통한 자원은 인스턴스 자원일때 가능

### 메서드
   - 객체를 만들기 위해 클래스를 만든다.
   - 객체에서 제일 중요한건 메서드
   - 인스턴스 메서드 : 객체를 만들면 접근할 수있는 메서드
   - 정적 메서드 : 메서드만 가지고 접근할수 있다.
   - 상수와 같이 
   - 동일한 자원을 호출한다. 가상 메서드 테이블
   - 상속을 통해 상위 클래스를 바꾼다.
   - 상속은 인스턴스 자원만

## 인터페이스(interface)
- 목적이 명확한 클래스
- 설계 만을 위한 클래스
- 추상 메서드만 정의 : 설계 명세
- implements 인터페이스 ...
- 제한적인 클래스의 일종

implements : 구현하다